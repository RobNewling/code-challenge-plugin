// Code generated by protoc-gen-go. DO NOT EDIT.
// source: plugin.proto

package plugin

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// The request message containing the user's name.
type DiscoverRequest struct {
	// In a real plugin the settings would be conveyed in a JSON object
	// with a schema defined by the plugin and populated by a user through a UI.
	// For this challenge we'll define a message for the settings
	// to make it easier for the host to create the settings.
	Settings             *Settings `protobuf:"bytes,1,opt,name=settings,proto3" json:"settings,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *DiscoverRequest) Reset()         { *m = DiscoverRequest{} }
func (m *DiscoverRequest) String() string { return proto.CompactTextString(m) }
func (*DiscoverRequest) ProtoMessage()    {}
func (*DiscoverRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_plugin_747ce3600609d2a2, []int{0}
}
func (m *DiscoverRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DiscoverRequest.Unmarshal(m, b)
}
func (m *DiscoverRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DiscoverRequest.Marshal(b, m, deterministic)
}
func (dst *DiscoverRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiscoverRequest.Merge(dst, src)
}
func (m *DiscoverRequest) XXX_Size() int {
	return xxx_messageInfo_DiscoverRequest.Size(m)
}
func (m *DiscoverRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DiscoverRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DiscoverRequest proto.InternalMessageInfo

func (m *DiscoverRequest) GetSettings() *Settings {
	if m != nil {
		return m.Settings
	}
	return nil
}

type Settings struct {
	// This a glob specifying the pattern to use to find files.
	// This will be an absolute path something like /src/data/*/*.csv.
	// The plugin should find all files matching the pattern, then
	// analyze them to find the unique schemas among them (multiple files
	// may have the same schema).
	//
	// For this challenge you can assume that all CSV files have a header row,
	// and that all files are comma delimited
	FileGlob             string   `protobuf:"bytes,1,opt,name=fileGlob,proto3" json:"fileGlob,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Settings) Reset()         { *m = Settings{} }
func (m *Settings) String() string { return proto.CompactTextString(m) }
func (*Settings) ProtoMessage()    {}
func (*Settings) Descriptor() ([]byte, []int) {
	return fileDescriptor_plugin_747ce3600609d2a2, []int{1}
}
func (m *Settings) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Settings.Unmarshal(m, b)
}
func (m *Settings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Settings.Marshal(b, m, deterministic)
}
func (dst *Settings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Settings.Merge(dst, src)
}
func (m *Settings) XXX_Size() int {
	return xxx_messageInfo_Settings.Size(m)
}
func (m *Settings) XXX_DiscardUnknown() {
	xxx_messageInfo_Settings.DiscardUnknown(m)
}

var xxx_messageInfo_Settings proto.InternalMessageInfo

func (m *Settings) GetFileGlob() string {
	if m != nil {
		return m.FileGlob
	}
	return ""
}

type DiscoverResponse struct {
	// Array of schemas discovered.
	Schemas              []*Schema `protobuf:"bytes,1,rep,name=schemas,proto3" json:"schemas,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *DiscoverResponse) Reset()         { *m = DiscoverResponse{} }
func (m *DiscoverResponse) String() string { return proto.CompactTextString(m) }
func (*DiscoverResponse) ProtoMessage()    {}
func (*DiscoverResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_plugin_747ce3600609d2a2, []int{2}
}
func (m *DiscoverResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DiscoverResponse.Unmarshal(m, b)
}
func (m *DiscoverResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DiscoverResponse.Marshal(b, m, deterministic)
}
func (dst *DiscoverResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiscoverResponse.Merge(dst, src)
}
func (m *DiscoverResponse) XXX_Size() int {
	return xxx_messageInfo_DiscoverResponse.Size(m)
}
func (m *DiscoverResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DiscoverResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DiscoverResponse proto.InternalMessageInfo

func (m *DiscoverResponse) GetSchemas() []*Schema {
	if m != nil {
		return m.Schemas
	}
	return nil
}

type Schema struct {
	// The unique name of the schema; if there is no unique name
	// the plugin can generate one.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The settings the plugin will use for publishing when
	// this schema is included in a PublishRequest. This
	// can be any data the plugin wants to capture; the host
	// will treat it as an opaque blob.
	// Hint: this is a good place to store the file paths of all the
	// files which contain records with this schema.
	Settings string `protobuf:"bytes,2,opt,name=settings,proto3" json:"settings,omitempty"`
	// Array of the properties discovered for this schema.
	Properties           []*Property `protobuf:"bytes,3,rep,name=properties,proto3" json:"properties,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Schema) Reset()         { *m = Schema{} }
func (m *Schema) String() string { return proto.CompactTextString(m) }
func (*Schema) ProtoMessage()    {}
func (*Schema) Descriptor() ([]byte, []int) {
	return fileDescriptor_plugin_747ce3600609d2a2, []int{3}
}
func (m *Schema) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Schema.Unmarshal(m, b)
}
func (m *Schema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Schema.Marshal(b, m, deterministic)
}
func (dst *Schema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Schema.Merge(dst, src)
}
func (m *Schema) XXX_Size() int {
	return xxx_messageInfo_Schema.Size(m)
}
func (m *Schema) XXX_DiscardUnknown() {
	xxx_messageInfo_Schema.DiscardUnknown(m)
}

var xxx_messageInfo_Schema proto.InternalMessageInfo

func (m *Schema) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Schema) GetSettings() string {
	if m != nil {
		return m.Settings
	}
	return ""
}

func (m *Schema) GetProperties() []*Property {
	if m != nil {
		return m.Properties
	}
	return nil
}

type Property struct {
	// Name of the property, from the column header.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Type of the property; can be "string", "integer", "number", "datetime", "boolean"
	// This should be inferred if possible by analyzing the data.
	Type                 string   `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Property) Reset()         { *m = Property{} }
func (m *Property) String() string { return proto.CompactTextString(m) }
func (*Property) ProtoMessage()    {}
func (*Property) Descriptor() ([]byte, []int) {
	return fileDescriptor_plugin_747ce3600609d2a2, []int{4}
}
func (m *Property) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Property.Unmarshal(m, b)
}
func (m *Property) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Property.Marshal(b, m, deterministic)
}
func (dst *Property) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Property.Merge(dst, src)
}
func (m *Property) XXX_Size() int {
	return xxx_messageInfo_Property.Size(m)
}
func (m *Property) XXX_DiscardUnknown() {
	xxx_messageInfo_Property.DiscardUnknown(m)
}

var xxx_messageInfo_Property proto.InternalMessageInfo

func (m *Property) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Property) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type PublishRequest struct {
	Settings             *Settings `protobuf:"bytes,1,opt,name=settings,proto3" json:"settings,omitempty"`
	Schema               *Schema   `protobuf:"bytes,2,opt,name=schema,proto3" json:"schema,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *PublishRequest) Reset()         { *m = PublishRequest{} }
func (m *PublishRequest) String() string { return proto.CompactTextString(m) }
func (*PublishRequest) ProtoMessage()    {}
func (*PublishRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_plugin_747ce3600609d2a2, []int{5}
}
func (m *PublishRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PublishRequest.Unmarshal(m, b)
}
func (m *PublishRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PublishRequest.Marshal(b, m, deterministic)
}
func (dst *PublishRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublishRequest.Merge(dst, src)
}
func (m *PublishRequest) XXX_Size() int {
	return xxx_messageInfo_PublishRequest.Size(m)
}
func (m *PublishRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PublishRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PublishRequest proto.InternalMessageInfo

func (m *PublishRequest) GetSettings() *Settings {
	if m != nil {
		return m.Settings
	}
	return nil
}

func (m *PublishRequest) GetSchema() *Schema {
	if m != nil {
		return m.Schema
	}
	return nil
}

type PublishRecord struct {
	// This should be set to true if the record is not valid
	// because it violates the inferred schema in some way.
	// The invalid property should be written as `null` in data.
	Invalid bool `protobuf:"varint,1,opt,name=invalid,proto3" json:"invalid,omitempty"`
	// If the record is invalid this field should explain why.
	// This should include the property name and the original value.
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// Data contains the values for a single record.
	// The values should be provided as a JSON serialized array.
	Data                 string   `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PublishRecord) Reset()         { *m = PublishRecord{} }
func (m *PublishRecord) String() string { return proto.CompactTextString(m) }
func (*PublishRecord) ProtoMessage()    {}
func (*PublishRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_plugin_747ce3600609d2a2, []int{6}
}
func (m *PublishRecord) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PublishRecord.Unmarshal(m, b)
}
func (m *PublishRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PublishRecord.Marshal(b, m, deterministic)
}
func (dst *PublishRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublishRecord.Merge(dst, src)
}
func (m *PublishRecord) XXX_Size() int {
	return xxx_messageInfo_PublishRecord.Size(m)
}
func (m *PublishRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_PublishRecord.DiscardUnknown(m)
}

var xxx_messageInfo_PublishRecord proto.InternalMessageInfo

func (m *PublishRecord) GetInvalid() bool {
	if m != nil {
		return m.Invalid
	}
	return false
}

func (m *PublishRecord) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *PublishRecord) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func init() {
	proto.RegisterType((*DiscoverRequest)(nil), "plugin.DiscoverRequest")
	proto.RegisterType((*Settings)(nil), "plugin.Settings")
	proto.RegisterType((*DiscoverResponse)(nil), "plugin.DiscoverResponse")
	proto.RegisterType((*Schema)(nil), "plugin.Schema")
	proto.RegisterType((*Property)(nil), "plugin.Property")
	proto.RegisterType((*PublishRequest)(nil), "plugin.PublishRequest")
	proto.RegisterType((*PublishRecord)(nil), "plugin.PublishRecord")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PluginClient is the client API for Plugin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PluginClient interface {
	Discover(ctx context.Context, in *DiscoverRequest, opts ...grpc.CallOption) (*DiscoverResponse, error)
	Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (Plugin_PublishClient, error)
}

type pluginClient struct {
	cc *grpc.ClientConn
}

func NewPluginClient(cc *grpc.ClientConn) PluginClient {
	return &pluginClient{cc}
}

func (c *pluginClient) Discover(ctx context.Context, in *DiscoverRequest, opts ...grpc.CallOption) (*DiscoverResponse, error) {
	out := new(DiscoverResponse)
	err := c.cc.Invoke(ctx, "/plugin.Plugin/Discover", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginClient) Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (Plugin_PublishClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Plugin_serviceDesc.Streams[0], "/plugin.Plugin/Publish", opts...)
	if err != nil {
		return nil, err
	}
	x := &pluginPublishClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Plugin_PublishClient interface {
	Recv() (*PublishRecord, error)
	grpc.ClientStream
}

type pluginPublishClient struct {
	grpc.ClientStream
}

func (x *pluginPublishClient) Recv() (*PublishRecord, error) {
	m := new(PublishRecord)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// PluginServer is the server API for Plugin service.
type PluginServer interface {
	Discover(context.Context, *DiscoverRequest) (*DiscoverResponse, error)
	Publish(*PublishRequest, Plugin_PublishServer) error
}

func RegisterPluginServer(s *grpc.Server, srv PluginServer) {
	s.RegisterService(&_Plugin_serviceDesc, srv)
}

func _Plugin_Discover_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiscoverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServer).Discover(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugin.Plugin/Discover",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServer).Discover(ctx, req.(*DiscoverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Plugin_Publish_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PublishRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PluginServer).Publish(m, &pluginPublishServer{stream})
}

type Plugin_PublishServer interface {
	Send(*PublishRecord) error
	grpc.ServerStream
}

type pluginPublishServer struct {
	grpc.ServerStream
}

func (x *pluginPublishServer) Send(m *PublishRecord) error {
	return x.ServerStream.SendMsg(m)
}

var _Plugin_serviceDesc = grpc.ServiceDesc{
	ServiceName: "plugin.Plugin",
	HandlerType: (*PluginServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Discover",
			Handler:    _Plugin_Discover_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Publish",
			Handler:       _Plugin_Publish_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "plugin.proto",
}

func init() { proto.RegisterFile("plugin.proto", fileDescriptor_plugin_747ce3600609d2a2) }

var fileDescriptor_plugin_747ce3600609d2a2 = []byte{
	// 337 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x92, 0xcb, 0x6e, 0xf2, 0x30,
	0x10, 0x85, 0xc9, 0x0f, 0x7f, 0x48, 0x87, 0x96, 0xa2, 0x51, 0x2f, 0x11, 0xab, 0xca, 0x0b, 0xc4,
	0xa2, 0x42, 0x28, 0xdd, 0x22, 0xb1, 0xa9, 0xd4, 0x2d, 0x0a, 0x4f, 0x10, 0xc0, 0x80, 0xab, 0x10,
	0xbb, 0xb6, 0x41, 0xe2, 0x09, 0xfa, 0xda, 0x55, 0x7c, 0xeb, 0x25, 0x5d, 0x75, 0xe7, 0x73, 0xc6,
	0xf6, 0x77, 0x66, 0x6c, 0xb8, 0x14, 0xe5, 0x71, 0xc7, 0xaa, 0x89, 0x90, 0x5c, 0x73, 0x8c, 0xad,
	0x22, 0x73, 0xb8, 0x7e, 0x66, 0x6a, 0xcd, 0x4f, 0x54, 0xe6, 0xf4, 0xed, 0x48, 0x95, 0xc6, 0x47,
	0x48, 0x14, 0xd5, 0x9a, 0x55, 0x3b, 0x95, 0x46, 0x0f, 0xd1, 0xb8, 0x97, 0x0d, 0x26, 0xee, 0xec,
	0xd2, 0xf9, 0x79, 0xd8, 0x41, 0x46, 0x90, 0x78, 0x17, 0x87, 0x90, 0x6c, 0x59, 0x49, 0x5f, 0x4a,
	0xbe, 0x32, 0x27, 0x2f, 0xf2, 0xa0, 0xc9, 0x0c, 0x06, 0x9f, 0x20, 0x25, 0x78, 0xa5, 0x28, 0x8e,
	0xa1, 0xab, 0xd6, 0x7b, 0x7a, 0x28, 0x6a, 0x50, 0x7b, 0xdc, 0xcb, 0xfa, 0x01, 0x64, 0xec, 0xdc,
	0x97, 0xc9, 0x2b, 0xc4, 0xd6, 0x42, 0x84, 0x4e, 0x55, 0x1c, 0xa8, 0xbb, 0xdf, 0xac, 0x6b, 0x6e,
	0x48, 0xfc, 0xcf, 0x72, 0xbd, 0xc6, 0x29, 0x80, 0x90, 0x5c, 0x50, 0xa9, 0x19, 0x55, 0x69, 0xdb,
	0x60, 0x42, 0x3f, 0x0b, 0x5b, 0x39, 0xe7, 0x5f, 0xf6, 0x90, 0x0c, 0x12, 0xef, 0xff, 0x4a, 0x43,
	0xe8, 0xe8, 0xb3, 0xa0, 0x8e, 0x64, 0xd6, 0x64, 0x0b, 0xfd, 0xc5, 0x71, 0x55, 0x32, 0xb5, 0xff,
	0xd3, 0x14, 0x71, 0x04, 0xb1, 0x6d, 0xd5, 0xdc, 0xda, 0x1c, 0x84, 0xab, 0x92, 0x25, 0x5c, 0x05,
	0xce, 0x9a, 0xcb, 0x0d, 0xa6, 0xd0, 0x65, 0xd5, 0xa9, 0x28, 0xd9, 0xc6, 0x50, 0x92, 0xdc, 0x4b,
	0xbc, 0x81, 0xff, 0x54, 0x4a, 0x2e, 0x5d, 0x4e, 0x2b, 0xea, 0xf0, 0x9b, 0x42, 0x17, 0x69, 0xdb,
	0x86, 0xaf, 0xd7, 0xd9, 0x7b, 0x04, 0xf1, 0xc2, 0xe0, 0x70, 0x0e, 0x89, 0x7f, 0x25, 0xbc, 0xf7,
	0x19, 0x7e, 0x7c, 0x90, 0x61, 0xda, 0x2c, 0xd8, 0x07, 0x25, 0x2d, 0x9c, 0x41, 0xd7, 0x05, 0xc4,
	0xbb, 0x30, 0xe5, 0x6f, 0x93, 0x19, 0xde, 0x36, 0xfc, 0xba, 0x13, 0xd2, 0x9a, 0x46, 0xab, 0xd8,
	0x7c, 0xce, 0xa7, 0x8f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x35, 0xb1, 0xc4, 0x50, 0xac, 0x02, 0x00,
	0x00,
}
